
// Broadcast at specific time

/*
public scheduleAll() {
    const groupedByTime = this.activities.reduce((acc, activity) => {
        if (!acc[activity.startTime]) {
            acc[activity.startTime] = [];
        }
        acc[activity.startTime].push(activity);
        return acc;
    }, {} as Record<string, OGActivity[]>);

    for (const [time, activities] of Object.entries(groupedByTime)) {
        const [hour, minute] = time.split(':').map(Number);

        scheduleJob({ hour, minute }, () => {
            this.sendDailyBroadcast(time, activities);
        });
        console.log(`Scheduled broadcast for ${time}`);
    }
}
    
public async sendDailyBroadcast(time: string, activities: OGActivity[]) {
let message = `${time}:\n\n`;
activities.forEach(og => {
    message += `${this.formatMessage(og)}\n`;
});

try {
    await this.bot.api.sendMessage('@og_schedule_channel', message);
    console.log(`Broadcast sent for ${time}`);
} catch (error) {
    console.error(`Error sending broadcast for ${time}:`, error);
    }
}


// All OG Schedule

bot.command('list', (ctx) => {

    const activities = ogScheduler.getActivities();
    if (activities.length === 0) {
        return ctx.reply('No scheduled activities.');
    }

    const message = activities.map(act =>
        `${act.startTime}: SubOG${act.subOG} of District ${act.district} (${act.currentTR} â†’ ${act.nextTR} for ${act.nextActivity})`
    ).join('\n');

    return ctx.reply(`Scheduled Activities:\n\n${message}`);


});


*/
